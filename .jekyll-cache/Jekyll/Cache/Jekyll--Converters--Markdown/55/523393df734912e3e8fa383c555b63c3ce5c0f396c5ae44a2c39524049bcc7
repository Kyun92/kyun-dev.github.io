I"
<p><code class="highlighter-rouge">Will</code> 접두사가 붙은 메소드는 어떤 작업을 작동하기 전에 실행되는 메서드
<code class="highlighter-rouge">Did</code> 접두사가 붙은 메서드는 어떤 작업을 작동 한 후에 실행되는 메서드
<code class="highlighter-rouge">Mount</code> 는 <code class="highlighter-rouge">DOM</code> 이 생성되고 웹 브라우저상에 나타나는 것</p>

<p><img src="https://user-images.githubusercontent.com/35090976/78525208-7a4f0e80-7811-11ea-8bc3-7dad0e784ffb.png" alt="Untitled" /></p>

<h1 id="mount-마운트"><code class="highlighter-rouge">Mount</code> 마운트</h1>

<ul>
  <li><code class="highlighter-rouge">constructor</code> : 컴포넌트를 새로 만들 때마다 호출되는 클래스 생성자 메서드</li>
  <li><code class="highlighter-rouge">getDerivedStateFromrops</code> : <code class="highlighter-rouge">props</code> 에 있는 값을 <code class="highlighter-rouge">state</code> 에 넣을 때 사용하는 메서드</li>
  <li><code class="highlighter-rouge">redner</code> : 우리가 준비한 UI를 렌더링 하는 메서드</li>
  <li><code class="highlighter-rouge">componentDidMount</code> : 컴포넌트가 웹 브라우저상에 타나난 후 호출하는 메서드</li>
</ul>

<h1 id="update-업데이트"><code class="highlighter-rouge">Update</code> 업데이트</h1>

<p>컴포넌트는 다음 네 가지 경우에 업데이트된다.</p>

<ol>
  <li><code class="highlighter-rouge">props</code> 가 바뀔 때</li>
  <li><code class="highlighter-rouge">state</code> 가 바뀔 때</li>
  <li>부모 컴포넌트가 리렌더링될 때</li>
  <li><code class="highlighter-rouge">this.forceUpdate</code> 로 강제로 렌더링을 트리거할 때</li>
</ol>

<p>이 때 실행되는 메서드는</p>

<ul>
  <li><code class="highlighter-rouge">getDerivedStateFromProps</code> : <code class="highlighter-rouge">Props</code>의 변화에 따라 <code class="highlighter-rouge">state</code> 값에도 변화를 주고 싶을 때 사용</li>
  <li><code class="highlighter-rouge">shouldComponentUpdate</code> : 컴포넌트를 리렌더링 할지 말지 결정하는 메서드 → <code class="highlighter-rouge">return true or false</code>, <code class="highlighter-rouge">false</code> 이면 작업을 중단 ⇒ <code class="highlighter-rouge">this.forceUpdate()</code> 를 실행하면 이 단계를 건너뛴다.</li>
  <li><code class="highlighter-rouge">render</code> : 컴포넌트를 리렌더링</li>
  <li><code class="highlighter-rouge">getSnapshotBeforeUpdate</code> : 컴포넌트 변화를 <code class="highlighter-rouge">DOM</code> 에 반영하기 바로 직전에 호출하는 메서드</li>
  <li><code class="highlighter-rouge">componentDidUpdate</code> : 컴포넌트의 업데이트 작업이 끝난 후 호출되는 메서드</li>
</ul>

<h1 id="unmount-언마운트"><code class="highlighter-rouge">unmount</code> 언마운트</h1>

<p>컴포넌트를 <code class="highlighter-rouge">DOM</code> 에서 제거하는 것</p>

<ul>
  <li><code class="highlighter-rouge">componentWillUnmount</code> : 컴포넌트가 웹 브라우저상에서 사라지기 전에 호출하는 메서드</li>
</ul>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  import React from 'react';
  import LifeCycle from './LifeCycle';

  function getRandomcolor(params) {
  return '#' + Math.floor(Math.random() \* 16777215).toString(16);
  }

  class App extends React.Component {
  state = {
  color: '#000000'
  }
  handleClick = () =&gt; {
  this.setState({
  color: getRandomcolor()
  })
  }

      render() {
        return (
          &lt;&gt;
            &lt;LifeCycle color={this.state.color} /&gt;
            &lt;button onClick={this.handleClick}&gt;랜덤&lt;/button&gt;
          &lt;/&gt;
        );
      }

  }

  export default App;
</code></pre></div></div>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  import React, { Component } from 'react';

  export default class LifeCycle extends Component {
  state = {
  number: 0,
  color: null
  }

      myRef = null;

      constructor(props) {
        super(props);
        console.log('constructor');
      }

      static getDerivedStateFromProps(nextProps, prevState) {
        console.log('getDerivedStateFromProps');
        if (nextProps.color !== prevState.color) {
          return { color: nextProps.color }
        }
        return null
      }

      componentDidMount() {
        console.log('componentDidMount');
      }

      shouldComponentUpdate(nextProps, nextState) {
        console.log('shouldComponentUpdate', nextProps, nextState);
        return nextState.number &amp; 10 !== 4;
      }

      componentWillUnmount() {
        console.log('componentWillUnmount');
      }

      handleClick = () =&gt; {
        this.setState({
          number: this.state.number + 1
        })
      }

      getSnapshotBeforeUpdate(prevProps, prevState) {
        console.log('getSnapshotBeforeUpdate');
        if (prevProps.color !== this.props.color) {
          return this.myRef.style.color;
        }
        return null
      }

      componentDidUpdate(prevProps, prevState, snapshot) {
        console.log('componentDidUpdate', prevProps, prevState);
        if (snapshot) {
          console.log('업데이트되지 직전 색상', snapshot);
        }
      }
      render() {
        console.log('render');
        const style = {
          color: this.props.color
        }

        return (
          &lt;div&gt;
            &lt;h1 style={style} ref={ref =&gt; this.myRef = ref}&gt;{this.state.number}&lt;/h1&gt;
            &lt;p&gt;color : {this.state.color}&lt;/p&gt;
            &lt;button onClick={this.handleClick}&gt;더하기&lt;/button&gt;
          &lt;/div&gt;
        )
      }

  }
</code></pre></div></div>
:ET